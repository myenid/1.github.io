## linux动态链接中的PLT和GOT

```c
#include <stdio.h>

void print_banner()
{
    printf("Welcome to World of PLT and GOT\n");
}

int main(void)
{
    print_banner();

    return 0;
}
```

看这个例子，gcc编译一下，

```shell
gcc -Wall -g -o test.o -c test.c -m32
```

然后链接test.o文件。

```shell
gcc -o test test.o -m32
```

注意这里生成的是i386架构的指令，而不是x86_64的。

test文件中，print_banner函数的汇编指令如下。

只是猜测，而不是ida里面的结果。

```
080483cc <print_banner>:
 80483cc:    push %ebp
 80483cd:    mov  %esp, %ebp
 80483cf:    sub  $0x8, %esp
 80483d2:    sub  $0xc, %esp
 80483d5:    push $0x80484a8  
 80483da:    call **<printf函数的地址>**
 80483df:    add $0x10, %esp
 80483e2:    nop
 80483e3:    leave
 80483e4:    ret
```

这个函数调用了printf函数，而这个函数存在于程序的动态链接库里面，所以在编译和链接这两个阶段的时候，链接器是无法知道，运行起来之后printf函数的加载地址，**所以call后面的内容，呀就是<printf函数的地址>是不知道是多少的**，只有程序正常运行之后才能够知道是多少。

那么问题来了:**汇编指令是肯定有的，那么程序运行起来之后，call指令如何重定位呢？**

显而易见，我们想到的肯定是，直接修改<printf函数的地址>为真正的地址即可。但是这样也有几个问题。

```markdown
- 现代操作系统不允许修改代码段，只能修改数据段
- 如果print_banner函数是在一个动态库(.so对象内)，修改代码段之后，就无法做到系统内所有进程共享一个动态库
```

**因此，printf函数地址只能回写到数据段内，而不能回写到代码段上。**

注意：刚才谈到的回写，是指运行时修改，更专业的称谓应该是**运行时重定位**，与之相对应的还有**链接时重定位**。

说到这里，需要把编译链接过程再展开一下。我们知道，每个编译单元（通常是一个.c文件，比如前面例子中的test.c）都会经历编译和链接两个阶段。

编译阶段是将.c源代码翻译成汇编指令的中间文件，比如上述的test.c文件，经过编译之后，生成test.o中间文件。print_banner函数的汇编指令如下（使用强调内容**objdump -d test.o**命令即可输出）：

```
00000000 <print_banner>:
      0:  55                   push %ebp
      1:  89 e5                mov %esp, %ebp
      3:  83 ec 08             sub   $0x8, %esp
      6:  c7 04 24 00 00 00 00 movl  $0x0, (%esp)
      d:  e8 fc ff ff ff       call  e <print_banner+0xe>
     12:  c9                   leave
     13:  c3                   ret
```

是否注意到call指令的操作数是fc ff ff  ff，翻译成16进制数是0xfffffffc（x86架构是小端的字节序），看成有符号是-4。这里应该存放printf函数的地址，但由于编译阶段无法知道printf函数的地址，所以预先放一个-4在这里，然后用重定位项来描述：**这个地址在链接时要修正，它的修正值是根据printf地址（更确切的叫法应该是符号，链接器眼中只有符号，没有所谓的函数和变量）来修正，它的修正方式按相对引用方式**

这个过程称为**链接时重定位**，与刚才提到的运行时重定位工作原理完全一样，只是修正时机不同。

**链接阶段**是将一个或者多个中间文件（.o文件）通过链接器将它们链接成一个可执行文件，链接阶段主要完成以下事情：

> - 各个中间文之间的同名section合并
> - 对代码段，数据段以及各符号进行地址分配
> - 链接时重定位修正

除了重定位过程，其它动作是无法修改中间文件中函数体内指令的，而重定位过程也只能是修改指令中的操作数，换句话说，**链接过程无法修改编译过程生成的汇编指令,只能够改变其中的操作数**

那么问题来了：**编译阶段怎么知道printf函数是在glibc运行库的，而不是定义在其它.o中**

答案往往令人失望：**编译器是无法知道的**

意思就是，编译器printf函数是哪里来的，它只能够老老实实的生成**调用**printf的汇编指令，printf是在glibc动态库定位，或者是在其它.o定义这两种情况下，它都能工作。如果是在其它.o中定义了printf函数，那在链接阶段，printf地址已经确定，可以直接重定位。如果printf定义在动态库内（链接阶段是可以知道printf在哪定义的，只是如果定义在动态库内不知道它的地址而已），链接阶段无法做重定位。

根据前面讨论，运行时重定位是无法修改代码段的，只能将printf重定位到数据段。那在编译阶段就已生成好的call指令，怎么感知这个已重定位好的数据段内容呢？

答案是：**链接器生成一段额外的小代码片段，通过这段代码支获取printf函数地址，并完成对它的调用**。

如下

```
.text
...

// 调用printf的call指令
call printf_stub
...

printf_stub:
    mov rax, [printf函数的储存地址] // 获取printf重定位之后的地址
    jmp rax // 跳过去执行printf函数

.data
...
printf函数的储存地址：
　　这里储存printf函数重定位后的地址
```

可以看到，.text段里面的调用指令，没有直接调用printf函数，而是调用了一个中间函数，通过这个函数，连接到.data段，然后.data数据段的地址存储printf重定位之后的代码。

这样就可以只修改数据段，并且完成重定位。

## 动态链接姐妹花PLT与GOT

> 前面的内容说完，可以总结为两点。
>
> - 存放外部数据的数据段
> - 链接过程生成的额外代码

这样就可以引申到表了，如果一个程序链接的时候，有许多这样的函数，那么这些函数的上面两个东西就会组成一个表。每个函数使用当中的一项。

被命名为GOT表(**重局偏移表** Global Offset Table)，而那个额外存放代码段的表，就是**程序链接表**(PLT procedure Link Table).

最后以一张图来简略介绍二者运行机制。（究极简略版）

![image-20210206152245704](C:\Users\lsp\AppData\Roaming\Typora\typora-user-images\image-20210206152245704.png)

就是如上一个一层一层查找的过程。